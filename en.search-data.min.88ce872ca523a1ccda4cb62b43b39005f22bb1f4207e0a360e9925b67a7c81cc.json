[{"id":0,"href":"/contests/i1/announcement/","title":"Announcement","section":"IF Untan Internal Contest #1","content":"Kita akan adakan IF Untan Internal Contest #1.\nWarm-up #   Contest URL: codeforces.com/contests/359459 Waktu: 29 Januari 2022 (09:00-14:00 UTC+7) Durasi: 5 jam Problems: 7  Warm-up bersifat optional namun dianjurkan. Score warm-up diabaikan.\nContest #   Contest URL: codeforces.com/contests/358294 Waktu: 30 Januari 2022 (09:00-14:00 UTC+7) Durasi: 5 jam Problems: 12  Scoreboard akan difreeze 1 jam terakhir dan diunfreeze 31 Januari 2022 00:00 UTC+7.\nPrizes #     # Prize     1st Rp1.000.000   2nd Rp750.000   3rd Rp500.000   4th-10th Rp250.000    Registration #  Lakukan registrasi di sini. Registrasi hanya perlu dilakukan satu kali.\nSetelah diinvite, gunakan contest URL di atas untuk menuju contest.\nDaftar participant yang telah diinvite akan diumumkan 27 Januari 2022 00:00 UTC+7.\nGood luck everyone!\n"},{"id":1,"href":"/contests/register/","title":"Cara Register Contest","section":"Contests","content":"Belum memiliki account CodeForces #   Register account CodeForces.  Sudah memiliki account CodeForces #   Register di form yang ada, gunakan handle (username) CodeForces yang Anda register di tahap sebelumnya.  Anda hanya perlu melakukan registrasi satu kali untuk mengikuti keseluruhan contest.\nSudah registrasi #  Anda sudah selesai melakukan registrasi.\nAnda akan diinvite ke contest setidaknya 2 hari sebelum tanggal warm-up.\nDaftar participant yang telah diinvite akan diumumkan 2 hari sebelum tanggal warm-up.\nSetelah registrasi #  Selagi menunggu, Anda dianjurkan untuk menelusuri atau menggunakan platform CodeForces untuk latihan atau mencoba sistem submission.\nBerikut resource yang juga dapat Anda gunakan untuk belajar mengenai algoritma, data struktur, dan programming in general:\n Introduction to Algorithms (The MIT Press), CLRS Algorithms (4th Edition), Sedgewick C Programming Language, K\u0026amp;R Competitive Programmer\u0026rsquo;s Handbook, Laaksonen  "},{"id":2,"href":"/contests/i1/participants/","title":"Participants","section":"IF Untan Internal Contest #1","content":" Acedias AkmalSkrn11 anisamuharni arinishfa bahrulAM berak boykagura chioyo D1041211075 divaadinda19 elsandri esmoel fathimahnur FauzanAdz fikatt26 flammingcat galuhksmptri GilangHanie hanuaex35 ibnuzhm Ilham12 isaacmarpaung J0o. Judithya kennyarlexy Khoir.A KhtrinaCl KnightJack_UNTAN le_jojot marissa.ana mei123ly mhakimsaputra17 MrArvon Musss nicholascannavaro osifunny Pandulaou_666 Prav13 rendykurniawan rezarahma sellinoventi shidiq tafifa Taneee Trustprn Ur_crush willyferry001 WzLaughez  "},{"id":3,"href":"/contests/i1/questions/","title":"Pertanyaan Teknis","section":"IF Untan Internal Contest #1","content":"Contest dilakukan secara online atau offline? #  Online.\n  Anda dapat menggunakan buku atau catatan apapun, termasuk kode yang pernah Anda ketik. Semua resource yang Anda gunakan harus ada sebelum contest dimulai.\n  Anda tidak diperbolehkan untuk membahas topik atau hal yang berkaitan dengan problem yang ada dengan siapapun, termasuk dengan peserta lain. Anda hanya dapat bertanya melalui sistem question saat contest berlangsung.\n  Pertanyaan klarifikasi terkait problem yang ada harus ditanyakan dalam bahasa Indonesia atau bahasa Inggris. Pertanyaan harus ditulis dengan jelas. Apabila tidak, maka juri berhak untuk tidak mempertimbangkan pertanyaan dan menjawab \u0026ldquo;no comment\u0026rdquo;.\n  Apakah ada ketentuan IDE atau text editor yang digunakan selama perlombaan? #  Tidak.\nApakah peserta lomba diperbolehkan untuk melakukan browsing selama perlombaan? #  Ya.\nApakah kecepatan pengerjaan mempengaruhi nilai? #  Ya.\n  Waktu yang diperlukan untuk menyelesaikan problem adalah waktu pertama submission menerima verdict Accepted, ditambah 20 menit waktu penalti untuk setiap submission yang tidak Accepted sebelum itu.\n  Tidak ada waktu penalti diberikan untuk problem yang tidak menerima verdict Accepted.\n  Scoreboard diurutkan berdasarkan jumlah problem yang telah disolve, kemudian total waktu solve problem tercepat.\n  Untuk bahasa yang digunakan apakah dibebaskan? #  Ya.\n Anda dapat menggunakan language yang telah disupport platform CodeForces. Semua problem dijamin dapat diselesaikan dengan C++ dan Python.  Untuk sistem pengerjaan apakah dilakukan secara real-time (maksud real-time disini adalah para peserta dimasukan ke dalam sebuah room online seperti meet/zoom)? #  Tidak.\nApakah pada saat kompetisi nanti akan ada tatap muka (offline dan online)? #  Tidak.\nApakah kontes akan diadakan secara offline di kampus? #  Tidak.\nApakah keterlambatan mengikuti lomba dapat membuat gugur perserta? #  Tidak.\nPerlu diingat bahwa kontes akan berakhir pada waktu yang sama untuk semua peserta.\nApabila peserta tidak dapat mengikuti warm up apakah akan gugur? #  Tidak.\nWarm-up bersifat optional namun dianjurkan. Score warm-up diabaikan.\nBerapa lama limit waktu pengerjaan per soal? #  5 jam.\nAnda dapat mengirimkan submission untuk setiap soal selama waktu kontes belum berakhir. Namun, eksekusi program harus memenuhi batasan waktu dan memori yang ada pada setiap soal.\nApabila saya tidak bisa memecahkan source kode apakah akan ada sanksi? #  Tidak.\nWaktu penalti hanya akan dihitung untuk soal yang sudah mendapatkan verdict Accepted.\n"},{"id":4,"href":"/contests/i1/editorial-warmup/","title":"Warm-up Editorial","section":"IF Untan Internal Contest #1","content":"Problem A: Waktu #   Hint 1 ↕  Tiga karakter terakhir tidak berubah     Hint 2 ↕  \\(29:00 = 05:00\\)     Solution ↕  Terdapat banyak cara untuk menyelesaikan soal ini. Kita dapat mengasumsikan bahwa \\(Y\\) memiliki format HH:MM. Selanjutnya, perhatikan bahwa tiga karakter terakhir tidak akan berubah sebab kita hanya menambah waktu di bagian jam.\nSaat menambah waktu di bagian jam, jangan lupa untuk dimodulo \\(24\\) sebab 2 jam setelah \\(23:00\\) adalah \\(01:00\\), bukan \\(25:00\\). Pastikan juga bahwa Anda mencetak \\(01:00\\), bukan \\(1:00\\) atau \\(1:0\\).\n  \\(\\)  Kompleksitas waktu: \\(O(1)\\).\n   Problem B: Tukar #   Hint 1 ↕  \\(s_i \\stackrel{?}{=} s_j\\)     Hint 2 ↕  Posisi \\(i\\) dan \\(j\\) adalah 1-indexed     Solution ↕  Kita hanya perlu mengecek apakah karakter yang ditukar adalah karakter yang berbeda. Apabila ya, maka stringnya pasti berbeda. Sebaliknya, string pasti sama.\nBerdasarkan batasan yang ada, posisi \\(i\\) dan \\(j\\) adalah 1-indexed. Sehingga, jangan lupa untuk diubah menjadi 0-indexed saat pengecekan.\nKompleksitas waktu: \\(O(1)\\).\n   Problem C: Rerata #   Hint ↕  Angka desimal yang mungkin hanya \\(.5\\)     Solution ↕  Implementasi dengan perhitungan floating point akan TLE atau WA dikarenakan precision error. Namun, karena kita hanya diminta untuk menghitung rata-rata dua bilangan bulat \\(a\\) dan \\(b\\), perhatikan bahwa hasilnya pasti genap apabila \\(a+b\\) genap, dan hasilnya pasti mengandung \\(.5\\) sebagai desimal apabila \\(a+b\\) ganjil.\nSehingga, salah satu solusinya adalah mencetak hasil dari pembagian bilangan bulat \\(a+b\\) oleh \\(2\\) (di mana pembagian antara dua bilangan bulat akan ditruncate), kemudian mencetak \\(.5\\) sebagai desimal apabila \\(a+b\\) ganjil.\nKompleksitas waktu: \\(O(n)\\).\n   Problem D: Travel #   Hint ↕  for loop ketiga tidak diperlukan     Solution ↕  Kita diminta untuk menghitung banyak solusi yang memenuhi:\n$$ n_1 + n_2 + n_3 = y $$\nuntuk \\(1 \\leq n_1, n_2, n_3 \\leq k\\).\nIterasi dari \\(1\\) hingga \\(k\\) untuk \\(n_1\\) dan \\(n_2\\). Dari sini, nilai dari \\(n_3\\) dapat diselesaikan dari persamaan di atas:\n$$ n_3 = y - n_1 - n_2 $$\nApabila \\(n_3\\) memenuhi \\(1 \\leq n_3 \\leq k\\), maka solusi ini valid.\nKompleksitas waktu: \\(O(k^2)\\).\n   Problem E: Inverse #   Hint ↕  $$ (5!)! \\gg 10^{10^{10}} $$     Solution ↕  Semua solusi yang memenuhi batasan yang ada adalah:\n \\(1 \\rightarrow (1!)!\\) \\(2 \\rightarrow (2!)!\\) \\(720 \\rightarrow (3!)!\\) \\(620448401733239439360000 \\rightarrow (4!)!\\)  nilai dari bilangan selanjutnya, \\(f(5) = (5!)!\\) mengandung 199 digit, yang jauh melebihi batasan masukan.\nKompleksitas waktu: \\(O(1)\\).\n   Problem F: Operasi Array #   Hint ↕  Tetapkan suatu \\(flag\\) untuk mengecek apakah nomor urutan array sudah dicetak atau belum     Solution ↕  Perhatikan bahwa kita tidak perlu menyimpan nilai median atau rata-rata sebenarnya untuk setiap array. Sebagai contoh, saat kita membandingkan rata-rata array \\(A\\) dan \\(B\\) yang berisi 3 bilangan bulat:\n$$ \\frac{(A_1+A_2+A_3)}{3} \u0026hellip; \\frac{(B_1+B_2+B_3)}{3} $$\nkita dapat mengalikan kedua sisi dengan jumlah elemen array, 3, sehingga kita tinggal membandingkan hasil penjumlahannya saja:\n$$ (A_1 + A_2 + A_3) \u0026hellip; (B_1 + B_2 + B_3) $$\nLogika yang sama dapat diterapkan untuk median array.\nMisalkan \\(C\\) mengandung nilai median setiap array beserta nomor urutannya, dan \\(D\\) mengandung nilai rata-rata setiap array beserta nomor urutannya. Array \\(C\\) dan \\(D\\) kemudian diurutkan berdasarkan nilai. Apabila nilainya sama, maka nomor urutan yang paling kecil yang didahulukan.\nSelanjutnya, Tetapkan boolean array \\(flag\\) untuk mengecek apakah nomor urutan array ini sudah dihapus atau belum. Pada awalnya, nilai array \\(flag\\) dari \\(1\\) hingga \\(n\\) adalah false.\nKemudian, kita mulai iterasi untuk array \\(C\\) dan \\(D\\). Selama semua elemennya belum ditelusuri, kita akan cek apakah nomor urutan array sudah dihapus atau belum. Apabila sudah, maka kita tidak mencetak apa-apa. Apabila belum, maka kita akan mencetak nomor urutan array ini dan menandai nomor urutan array di \\(flag\\) menjadi true. Setelah itu, kita pindah ke operasi selanjutnya (dari \\(C\\) ke \\(D\\) atau sebaliknya).\nKompleksitas waktu: \\(O(nm)\\).\n   Problem G: Barisan Genap #   Hint ↕  Ubah barisan ke modulo \\(2\\)     Solution ↕  Karena kita hanya melihat ganjil/genap, maka barisan yang ada dapat kita modulo \\(2\\), di mana \\(0\\) berarti genap dan \\(1\\) berarti ganjil. Setiap operasi yang John lakukan kemudian akan mengubah \\(0\\) menjadi \\(1\\), atau \\(1\\) menjadi \\(0\\).\nSelanjutnya, perhatikan bahwa urutan operasi tidak berpengaruh terhadap solusi. Kemudian, apabila terdapat solusi, maka solusi yang optimal tidak akan melebihi \\(n\\), sebab memilih \\(i\\) yang sama sebanyak dua kali tidak memiliki pengaruh apa-apa.\nKita dapat mencoba semua kombinasi untuk semua \\(i\\) yang dipilih dari \\(1\\) hingga \\(n\\).\nKompleksitas waktu: \\(O(2^n)\\).\n   "},{"id":5,"href":"/contests/i1/results/","title":"Results","section":"IF Untan Internal Contest #1","content":"Terima kasih telah mengikuti IF Untan Internal Contest #1!\nScoreboard telah diunfreeze.\nWinners #  Selamat kepada para pemenang:\n   Place Name CF Handle     1ˢᵗ MEILY mei123ly   2ⁿᵈ JONATHAN DARIUS J0o.   3ʳᵈ STANLEY BALDWIN osifunny   4ᵗʰ Nicholas Cannavaro nicholascannavaro   5ᵗʰ Gilang Muhammad Hasbillah Hanie GilangHanie   6ᵗʰ Willy Ferry willyferry001   7ᵗʰ Ade Rizaldi flammingcat   8ᵗʰ Kenny Arlexy kennyarlexy   9ᵗʰ Ardian Arvon MrArvon   10ᵗʰ Bahrul Alam Malindo bahrulAM    Form claim prize telah dikirimkan ke email masing-masing. Silakan isi form untuk claim prize. Pengisian form ditutup pada tanggal 6 Februari 2022 pukul 23:59 WIB.\nFirst Solve #  Berikut first solve untuk setiap problem:\n   Problem Time Name CF Handle     Balik 00:05 Akmal Sakirin AkmalSkrn11   Jumlah 00:16 Meily mei123ly   Lukisan 00:22 Jonathan Darius J0o.   Bermain Geometri 00:38 Jonathan Darius J0o.   Nomor 01:51 Kenny Arlexy kennyarlexy   Bagi - - -   Nilai 03:56 Kenny Arlexy kennyarlexy   Farming - - -   Tahun 03:34 Ade Rizaldi flammingcat   Pos Ronda - - -   Menyusun Buku - - -   Kartu Tarot 02:27 Ardian Arvon MrArvon    Editorial #  Editorial sudah dapat diakses.\nPractice mode akan diset keesokan harinya. Anda dapat upsolve problem contest (termasuk warm-up) dan melihat status submission secara lengkap.\nSampai jumpa di contest selanjutnya!\n"},{"id":6,"href":"/contests/i1/editorial-contest/","title":"Contest Editorial","section":"IF Untan Internal Contest #1","content":"Problem A: Balik #   Hint 1 ↕    \\(1 \\leq x \\leq 10^{30}\\)      Hint 2 ↕  String     Hint 3 ↕  Posisi digit pertama yang tidak nol setelah string dibalik     Solution ↕  Salah satu solusinya adalah dengan mengambil input sebagai string, kemudian membalikkan string tersebut. Setelah string dibalik, kita hanya akan mulai mencetak digit apabila kita menemukan digit yang tidak nol pada string.\nKompleksitas waktu: \\(O(|x|)\\), di mana \\(|x|\\) adalah panjang digit bilangan.\n   Problem B: Jumlah #   Hint 1 ↕  1 1 1000000000      Hint 2 ↕  Deret aritmatika     Hint 3 ↕  \\(n = (b-a+1)\\), \\(U_1 = a\\), \\(U_n = b\\)     Solution ↕  Kita dapat gunakan penjumlahan deret untuk menyelesaikan soal ini\n$$ S_n = \\frac{n(U_1+U_n)}{2} $$\ndi mana \\(n = (b-a+1)\\) adalah jumlah suku, \\(U_1 = a\\) adalah suku pertama dan \\(U_n = b\\) adalah suku terakhir. Sehingga perintah a b berarti hasil dari\n$$ S_n = \\frac{(b-a+1)(a+b)}{2} $$\nKarena nilai \\(S_n\\) dapat melebihi \\(10^9\\), gunakan tipe data yang dapat memuat bilangan yang lebih besar seperti long long.\nKompleksitas waktu: \\(O(n)\\) di mana \\(n\\) adalah jumlah perintah.\nCatatan: Time limit untuk problem B awalnya adalah 1 sekon. Namun, solusi yang benar, yang selalu melakukan operasi flush akan TLE. Juri merasa ini merupakan hal yang tidak penting sebagai bagian solusi dari problem B. Untuk dari itu, time limit diubah menjadi 3 sekon.\n   Problem C: Lukisan #   Hint 1 ↕  Simpan lukisan yang tersisa di suatu array terlebih dahulu     Hint 2 ↕  Output harus sama persis (tanpa spasi berlebih)     Hint 3 ↕  Cetak spasi apabila bukan elemen terakhir. Setelah semua elemen telah dicetak, cetak new line.     Solution ↕  Kita akan menyimpan bilangan \\(x\\) ke suatu array \\(A\\) jika dan hanya jika \\(x \\neq p\\). Setelah membaca semua input, cetak kembali elemen yang tersimpan di array. Anda dapat menggunakan vector di C++ atau list di Python.\nKompleksitas waktu: \\(O(n)\\).\n   Problem D: Bermain Geometri #   Hint 1 ↕   Lingkaran: \\(\\pi r^2 = 3.14r^2\\) Segitiga sama sisi: \\(\\frac{\\sqrt{3}}{4}s^2\\) Persegi: \\(t^2\\)  Dapat dibuktikan tidak terdapat luas yang bernilai sama dengan batasan yang ada     Hint 2 ↕  Precision error dapat diabaikan apabila implementasi dilakukan secara hati-hati     Hint 3 ↕  \\(L = \\max(L_1, \\max(L_2, L_3))\\)     Solution ↕  Hitung luas setiap bangun datar, ambil nilai luas terbesar, dan cek bangun datar mana yang memiliki luas terbesar tersebut (asumsikan \\(\\pi = 3.14\\) seperti pada soal).\nKarena batasannya yang cukup kecil, maka precision error dapat diabaikan dan imlementasi yang menggunakan perhitungan floating point secara hati-hati juga diterima.\nKompleksitas waktu: \\(O(1)\\) setiap test case.\n   Problem E: Nomor #   Hint 1 ↕  Suatu bilangan habis dibagi 9 apabila hasil penjumlahan semua digit yang ada di bilangan habis dibagi 9     Hint 2 ↕  Dua angka pertama diabaikan saat mengecek pengulangan angka     Hint 3 ↕  \\(a_1a_2a_3\u0026hellip;\\)\n\\(a_1+a_2=9\\)\n    Solution ↕  Dapat dipastikan ada jawaban. Berikut ditunjukkan salah satu caranya.\nKarena dua angka pertama diabaikan, maka kita dapat menulis 9 sebagai digit pertama, kemudian menulis 0 untuk digit sisanya.\nKompleksitas waktu: \\(O(n)\\).\n   Problem F: Bagi #   Hint 1 ↕  $$ \\sum_{i=1}^{n} k_i \\gg 10^6 $$     Hint 2 ↕  $$ 1 \\leq n \\leq 25 $$     Hint 3 ↕  Bruteforce \\(2^n\\)     Solution ↕  Perhatikan bahwa solusi DP akan TLE sebab nilai \\(k_i\\) dapat mencapai \\(10^9\\). Namun, karena \\(1 \\leq n \\leq 25\\), Anda dapat melakukan bruteforce untuk setiap kombinasi yang ada.\nKompleksitas waktu: \\(O(2^n)\\).\n   Problem G: Nilai #   Hint 1 ↕  DFS     Hint 2 ↕  Directed graph path     Hint 3 ↕  Jawabannya adalah suatu path dengan panjang 2     Solution ↕  Soal ini dapat diselesaikan dengan DFS. X \u0026gt; Y berarti terdapat directed edge dari X ke Y dan X \u0026lt; Y berarti terdapat directed edge dari Y ke X. Anda dapat melakukan DFS untuk semua karakter \u0026lsquo;A\u0026rsquo; hingga \u0026lsquo;Z\u0026rsquo;. Karena dipastikan ada satu jawaban, maka akan ditemukan satu path dengan panjang 2.\nKompleksitas waktu: \\(O(1)\\).\n   Problem H: Farming #   Hint 1 ↕  \\(f(t)\\) = total monster yang dibunuh Toni dan Budi pada menit \\(t\\)     Hint 2 ↕  $$ f(t) = \\left\\lfloor\\dfrac{t}{x}\\right\\rfloor + \\left\\lfloor\\dfrac{t}{y}\\right\\rfloor $$     Hint 3 ↕  Fungsi \\(f\\) menaik secara monotonik     Solution ↕  Misalkan fungsi \\(f\\) menandakan total monster yang dibunuh Toni dan Budi pada menit \\(t\\)\n$$ f(t) = \\left\\lfloor\\dfrac{t}{x}\\right\\rfloor + \\left\\lfloor\\dfrac{t}{y}\\right\\rfloor $$\nFungsi ini menaik, sehingga kita dapat melakukan binary search untuk menemukan jawabannya. Lakukan binary search sehingga ditemukan \\(t\\) maksimal sedemikian sehingga \\(f(t)\u0026lt;n\\). Menit \\(t+1\\) merupakan menit minimum di mana \\(f(t)=n\\).\nKompleksitas waktu: \\(O(\\log(n/\\min(x, y)))\\).\n   Problem I: Tahun #   Hint 1 ↕  Jawabannya tidak melebihi \\(5\\cdot 10^{12}\\)     Hint 2 ↕  Pola fungsi dapat ditebak     Hint 3 ↕  Characteristic polynomial     Solution ↕   Kita dapat lakukan bruteforce untuk nilai n yang kecil. Kompleksitas waktunya adalah \\(O(3^n)\\). Untuk \\(n \\leq 10^6\\), kita dapat menerapkan Dynamic Programming. Relasinya sudah disebutkan, jadi tinggal implementasi. Kompleksitas waktu dan memorinya adalah \\(O(n)\\). Namun, karena batasannya yang cukup besar, kita perlu menyelesaikan relasi ini. Relasinya adalah \\(f(n) = 2004+4n\\) untuk \\(n\\) genap dan \\(f(n) = 2006+4n\\) untuk \\(n\\) ganjil.  Kompleksitas waktu dan memorinya adalah \\(O(1)\\).    Problem J: Pos Ronda #   Hint 1 ↕  Graph berbentuk tree     Hint 2 ↕  Parent dari leaf yang ada di tree adalah bagian dari jawaban     Hint 3 ↕  Semua edge harus tercover     Solution ↕  Kita diminta untuk menemukan perumahan mana saja yang dijadikan pos ronda sehingga semua jalan dijaga setidaknya satu pos ronda.\nSederhananya, diberikan suatu connected graph \\(G\\) dengan \\(n\\) vertices dan \\(n−1\\) edges, kita diminta untuk menemukan himpunan \\(S\\) dengan jumlah minimum sehingga untuk setiap edge, salah satu endpointnya terdapat di \\(S\\) (vertex yang ada di \\(S\\) menyentuh setiap edge yang ada di \\(G\\)). Problem ini bersifat NP-hard. Namun, karena dijamin bahwa \\(G\\) berbentuk tree, maka kita dapat selesaikan dalam waktu polinomial.\nAmbil leaf \\(u\\) manapun pada tree. Misalkan parent dari \\(u\\) adalah \\(v\\). \\(v\\) merupakan bagian dari jawaban. Selanjutnya, hapus setiap edge yang terhubung ke \\(v\\). Ulangi proses ini hingga tidak ada edge yang tersisa.\nKompleksitas waktu: \\(O(n\\log(n))\\).\n   Problem K: Menyusun Buku #   Hint 1 ↕  Berapa banyak kemungkinan \\(n/2\\) susunan buku berada di tempat semula?     Hint 2 ↕  Berapa banyak kemungkinan \\(n/2\\) susunan buku yang tersisa tidak berada di tempat semula?     Hint 3 ↕  Derangement     Solution ↕  Misalkan terdapat \\(n\\) buku. Tetapkan tepat \\(\\frac{n}{2}\\) buku untuk berada di posisi awal. Terdapat \\(n \\choose n/2\\) kemungkinan untuk memilih susunan buku yang berada di posisi awal.\n\\(\\frac{n}{2}\\) buku yang tersisa harus diubah susunannya sehingga tidak ada dari buku tersebut yang berada di posisi semula. Ini merupakan jumlah derangement untuk \\(\\frac{n}{2}\\) elemen.\nSehingga, jawabannya adalah\n$$ {n \\choose n/2} d(n/2) $$\ndi mana \\(d(n)\\) adalah jumlah derangement untuk n elemen. Relasi untuk \\(d(n)\\) didapatkan sebagai berikut:\n  \\(d(1) = 0\\). Terdapat 0 cara untuk mengubah susunan 1 elemen sehingga tidak ada elemen yang berada di posisi semula.\n  \\(d(2) = 1\\). Terdapat 1 cara. Sebagai contoh, apabila A = [1, 2], maka A dapat disusun menjadi [2, 1].\n  \\(d(n) = (n-1)(d(n-1) + d(n-2))\\).\nMisalkan terdapat permutasi dari 1 hingga n. Kita akan hitung nilai \\(d(n)\\). Pertama-tama, kita akan mengganti elemen pertama. Terdapat \\(n−1\\) cara untuk melakukannya. Selanjutnya, bilangan ke \\(n\\) dapat ditukar dengan \\(1\\), sehingga kita tinggal mencari \\(d(n−2)\\), atau kita mengganti bilangan \\(n\\) dengan elemen lain selain \\(1\\), sehingga kemudian kita mencari \\(d(n−1)\\).\n  Kita dapat menggunakan Dynamic Programming untuk mendapatkan nilai \\(d(n/2)\\) secara efisien.\nKompleksitas waktu: \\(O(n)\\).\n   Problem L: Kartu Tarot #   Hint 1 ↕  Nomor urutan kartu berubah seiring kartu yang ada diambil     Hint 2 ↕   Kartu yang belum diambil = \\(1\\) Kartu yang sudah diambil = \\(0\\)      Hint 3 ↕  Untuk mengambil kartu ke-\\(i\\), ambil susunan kartu ke-\\(i\\) yang belum diambil     Solution ↕  Awalnya, intended solution untuk problem ini adalah dengan menggunakan segment tree:\n Kita dapat menggunakan segment tree. Untuk setiap kartu yang masih ada, kita tandai \\(1\\). Apabila telah diambil, kita tandai \\(0\\). Maka, untuk mengambil kartu ke-\\(i\\), kita akan menemukan index minimum \\(j\\) di mana jumlah array dari index \\(0\\) hingga index \\(j\\) adalah \\(i\\).\n  Kompleksitas waktu: \\(O(k\\log(n))\\).\n Namun, juri tidak mempertimbangkan semua implementasi yang memungkinkan, sehingga menimbulkan kesenjangan antara solusi yang naive dan solusi yang accepted. Oleh karena itu, constraint untuk problem ini diturunkan sedemikian sehingga kita dapat menggunakan brute force untuk menyelesaikan soalnya.\nUntuk setiap kartu yang diambil pada index \\(p_i\\), hapus kartu yang ada di index \\(p_i\\), cetak nama kartu, kemudian ulangi proses hingga semua \\(k\\) kartu diambil.\nKompleksitas waktu: \\(O(nk)\\).\n   "}]